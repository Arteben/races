  <HTML>
  <head>
    <meta charset="utf-8"/>
    <title> Races </title>
    <style>
    </style>
    <script src="js/playground-base.js"></script>
    <script src="js/raphael.js"></script>
  <head/>
  <body>
    <script>
    
    var params = {};

    var ENGINE = {};

    ENGINE.main = {
      
      // create game board
      create: function(){

        var app = this.app;
        var paper = app._svg_;
        var sizes = app._sizes_;
        
        var road_params = {
          cell: 20,
          radius: 50,
          size: 0,
          attr_road: {'stroke': '#556', 'stroke-width': 5, 'fill': '#DDD'},
          attr_island: {'stroke': '#556', 'stroke-width': 5, 'fill': "#484"},
          attr_finish: {'stroke': '#BB3', 'stroke-width': 10},
          get_size: function(){
            this.size = this.cell * this.radius;
          },
        };   
        
        road_params.get_size();
        
        this._road_p_ = road_params;
        
        var speed = 50;
        
        document.body.style.backgroundColor = road_params.attr_island.fill;
        
        // create array for road
        var road_array = (function(params){

          //count for create arrays;          
          var n, m;
                    
          var array = [];
          for (n = 0; n < params.radius; n++){
            array[n] = [];
            for (m = 0; m < params.radius; m++){
              array[n][m] = 0;
            }
          }
          
          var begin_insland = Math.floor(params.radius * 0.25) - 1;
          var end_insland = Math.floor(params.radius * 0.75) - 1;
          
          var i, j;
          
          for(i in array){
            if (i == 0 || i == array.length - 1) {
              for(j in array[i]){
                array[i][j] = 1;
              } 
            } else if((i > 0 && i < begin_insland) || (i >= end_insland && i < array.length)){
              for (j in array[i]){
                if (j == 0 || j == array[i].length - 1) {
                  array[i][j] = 1;
                }
              }
            } else if (i >= begin_insland && i < end_insland){
              for (j in array[i]){
                if (j == 0 || j == array[i].length - 1 || (j >= begin_insland && j < end_insland)){
                  array[i][j] = 1;
                }
              }
            }
          }
          
          var half = Math.floor(params.radius / 2 - 2);

          exit:
          
          for (m in array[half]){
            if (array[half][m] == 0){
              for (n = m; n < array[half].length; n++){      
                if (array[half][n] == 1){
                  break exit;
                } else {
                  array[half][n] = 2;
                }
              }
            }
          }
          
          return array;
                    
        }(road_params));
                
        var field = (function(array, p, svg){
          
          var path;
          var road;
          var island;
          var i, j, m, n;
          var cycle_points;
          var stright;
          var cell = p.cell;
          var half = Math.floor(p.radius / 2 - 2);
          // begin root, on clock
          var root;
          var count;
          var cycle;
          var point_up, point_down;
          var finish;
          var return_field;
          
          exit:
          for (i = 0; i < array.length; i++){
            for (j = 0; j< array[i].length; j++){
              if (array[i][j] == 2){
                point_up = {i: i, j: j};
                break exit; 
              }
            }
          }
          
          for (j = point_up.j; j <= array[point_up.i].length; j++){
            if (array[point_up.i][j] == 1){
              point_down = {i: point_up.i, j: j - 1};
              break;
            }
          }
          
          finish = 'M' + ((point_up.i + 0.5) * cell) + ',' + (point_up.j * cell) +
                    'L' +  ((point_down.i + 0.5) * cell) + ',' + ((point_down.j + 1) * cell);  
          
          root = 2;
          path = '';
          
          cycle_points = {
            i: point_up.i,
            j: point_up.j,
          };
          
          count = 0;
          cycle = 'up';

          // draw_border          
          draw_and_check_root = function(){
            
            if (count != 0 && array[cycle_points.i][cycle_points.j] == 2){
              path+= 'Z';

              if (cycle == 'up'){
                cycle_points = {
                  i: point_down.i,
                  j: point_down.j,
                };

                root = 1;
                count = 0;
                cycle = 'down';
                road = path;
                path = '';
              } else {
                island = path;
                return;
              }
            }
            
            if (count == 0){
              path += 'M';
            } else {
              if (!stright){
                path += 'L';
              }
            }
            
            m = cycle_points.i;
            n = cycle_points.j;
            
            stright = false;
            
            switch(root){
              case 0:
                
                if (array[m - 1] && (array[m - 1][n - 1] === 0 || array[m - 1][n - 1] == 2)){
                  root = 6;
                  cycle_points.i--;
                  cycle_points.j--;
                } else if (array[m][n - 1] === 0 || array[m][n - 1] == 2) {
                  cycle_points.j--;
                  stright = true;
                } else {
                  root = 2;
                }

                if (!stright){
                  path += (m * cell) + ',' + ((n + 1) * cell) + 'L' + (m * cell) + ',' + (n * cell);
                  count = 0;
                } 
                
              break;
              case 1:
                                
                if (array[m + 1] && (array[m + 1][n + 1] === 0 || array[m + 1][n + 1] == 2)){
                  root = 3;
                  cycle_points.i++;
                  cycle_points.j++;
                } else if (array[m + 1] && (array[m + 1][n] === 0 || array[m + 1][n] == 2)){
                  cycle_points.i++;
                  stright = true;                
                } else {
                  root = 7;
                }

                if (!stright){
                  path += (m * cell) + ',' + ((n + 1) * cell) + 'L' + ((m + 1) * cell) + ',' + ((n + 1) * cell);
                  count = 0;
                } 

              break;
              case 2:
              
                                
                if (array[m + 1] && (array[m + 1][n - 1] === 0 || array[m + 1][n - 1] == 2)){
                  root = 0;
                  cycle_points.i++;
                  cycle_points.j--;
                } else if (array[m + 1] && (array[m + 1][n] === 0 || array[m + 1][n] == 2)){
                  cycle_points.i++;
                  stright = true;
                } else {
                  root = 4;
                }

                if (!stright){
                  path += (m * cell) + ',' + (n * cell) + 'L' + ((m + 1) * cell) + ',' + (n * cell);
                  count = 0;
                } 

              break;
              case 3: 
                                
                if (array[m - 1] && (array[m - 1][n + 1] === 0 || array[m - 1][n + 1] == 2)){
                  root = 5;
                  cycle_points.i--;
                  cycle_points.j++;
                } else if (array[m][n + 1] === 0 || array[m][n + 1] == 2){
                  cycle_points.j++;
                  stright = true;                
                } else {
                  root = 1;
                }

                if (!stright){
                  path += (m * cell) + ',' + (n * cell) + 'L' + (m * cell) + ',' + ((n + 1) * cell);
                  count = 0;
                } 

              break;
              case 4:
                                
                if (array[m + 1] && (array[m + 1][n + 1] === 0 || array[m + 1][n + 1] == 2)){
                  root = 2;
                  cycle_points.i--;
                  cycle_points.j++;
                } else if (array[m][n + 1] === 0 || array[m][n + 1] == 2){
                  cycle_points.j++;
                  stright = true;                
                } else {
                  root = 6;
                }

                if (!stright){
                  path += ((m + 1) * cell) + ',' + (n * cell) + 'L' + ((m + 1) * cell) + ',' + ((n + 1) * cell);
                  count = 0;
                } 

              break;

              case 5:
                                
                if (array[m - 1] && (array[m - 1][n - 1] === 0 || array[m - 1][n - 1] == 2)){
                  root = 7;
                  cycle_points.i--;
                  cycle_points.j--;
                } else if (array[m - 1] && (array[m - 1][n] === 0 || array[m - 1][n] == 2)){
                  cycle_points.i--;
                  stright = true;                
                } else {
                  root = 3;
                }

                if (!stright){
                  path += ((m + 1) * cell) + ',' + (n  * cell) + 'L' + (m * cell) + ',' + (n * cell);
                  count = 0;
                } 


              break;            
              case 6:
                                
                if (array[m - 1] && (array[m - 1][n + 1] === 0 || array[m - 1][n + 1] == 2)){
                  root = 4;
                  cycle_points.i--;
                  cycle_points.j++;
                } else if (array[m - 1] && (array[m - 1][n] === 0 || array[m - 1][n] == 2)){
                  cycle_points.i--;
                  stright = true;                
                } else {
                  root = 0;
                }

                if (!stright){
                  path += ((m + 1) * cell) + ',' + ((n + 1) * cell) + 'L' + (m  * cell) + ',' + ((n + 1) * cell);
                  count = 0;
                } 

              break;
              case 7:
                
                if (array[m + 1] && (array[m + 1][n - 1] === 0 || array[m + 1][n - 1] == 2)){
                  root = 1;
                  cycle_points.i++;
                  cycle_points.j--;
                } else if (array[m][n - 1] === 0) {
                  cycle_points.j--;
                  stright = true;
                } else {
                  root = 5;
                }

                if (!stright){
                  path += ((m + 1) * cell) + ',' + ((n + 1) * cell) + 'L' + ((m + 1) * cell) + ',' + (n * cell);
                  count = 0;
                } 
              break;        
            }
            
            if (count > p.radius){
              return;
            } else {
              count++;
              draw_and_check_root();
            }
          };
          
          draw_and_check_root();
          
          //console.log(path);
          
          return_field = {            
            road: svg.path(road).attr(p.attr_road),
            island: svg.path(island).attr(p.attr_island),
            finish: {
              el: svg.path(finish).attr(p.attr_finish),
              point_up: point_up,
              point_down: point_down,
            },
          };
                  
          return return_field;
        }(road_array, road_params, paper));
                
        // for step, calcults numbers for renders
        // only move racer
        var steps_racer = {
          cycle: false,
          count: 0, 
          frames: 1000 / speed,
          bit: 0,
          begin_path: '',
          path: '',
          goal: {
            i: 0,
            j: 0,
            x: 0,
            y: 0,
          },
        };
        
        //var steps_rival = {
          //count: 0;
        //};
        
        // params for renders objects that moves
        var renders_racer = {        
          status: false,
          racer: {
            x: 0,
            y: 0,
          },
          viewBox: {
            set: false,
            x: 0,
            y: 0,
            w: 0,
            h: 0,
          },
          path: '',
        };

        var proto_racers = {

          speed: 0,
          // clock, begin - 0
          root: 0,
          current_speed_root: {
            s: 0,
            r: 0,
          },

          finish_on: 0,

          // current coords racer
          coord: {
            i: 0,
            j: 0,
            x: 0,
            y: 0,
          },
          
          point: null,
          path: null,
          path_anim: null,
          
          flay: [{s: 0, wait: 0}],
          
          cell: road_params.cell,
          
          del: function(){
            this.point.remove();
            this.path.el.remove();
            this.path_anim.remove();
          },
          
          create: function(){
            
            var fire = {
              width: 8,
              fill: false,
              opacity: 0.9,
              offsetx: 0,
              offsety: 0,
              color: 'rgb(255, 255, 100)'
            };  
            
            var glow = {  
              width: 6,
              fill: false,
              opacity: 0.8,
              offsetx: 0,
              offsety: 0,
              color: this.glow,
            };
            
            var s = this.cell;
                  
            this.path = {
              el: paper.path("").glow(glow),
              str: '',
            };
            
            this.path_anim = paper.path("").glow(fire);

            this.point = paper.path('').attr({'fill': this.fill, 'stroke-width': 1, 'stroke': '#000'});
          },         
          
          set_path: function(type, path){
            if (type == 'full'){
                this.path.str += path;
                this.path.el.attr({'path': this.path.str});            
            } else {
                this.path_anim.attr({'path': path});            
            }
          },
          
          set_racer: (function(){
            
            var path;
            
            var calc = function(xy, num, add){
                switch(num){
                  case '05':
                    if (add){
                      return xy + 0.25 * road_params.cell;
                    } else {
                      return xy -(0.25 * road_params.cell);
                    }
                  break;
                  case '025':
                    if (add) {
                      return xy + 0.1 * road_params.cell;
                    } else {
                      return xy -(0.1 * road_params.cell);
                    }
                }
            };
                        
            return function(x, y, root){
                     
              path = 'M' + calc(x, '05') + ',' + calc(y, '05', true) + 'L' + x + ',' + calc(y, '05') + 
                          'L' + calc(x, '05', true) + ',' + calc(y, '05', true) + 'L' + x + ',' + calc(y, '025', true) + 'Z';

              this.point.attr({'path': path, 'transform': 'r' + (root * 45)});
            
            };
          }()),
        };
                
        var CreateRacer = function(glow, fill){
        
          var xy;
        
          this.coord.i = field.finish.point_up.i + 2,
          this.coord.j = Math.round((field.finish.point_down.j - field.finish.point_up.j) / 2),
        
          this.glow = glow;
          this.fill = fill;
          this.create();
      
          this.path_anim.attr('path', '');
          this.path.str = '';
          this.path.el.attr('path', '');
          
          this.flay = [{s: 0, wait: 0}];
          
          this.root = 2;
          this.speed = 0;
          this.current_speed_root = {
            s: this.speed,
            r: this.root,
          };      
              
        };        
        
        CreateRacer.prototype = proto_racers;
                
        var popup = {
          el: document.body.appendChild(document.createElement('div')),
          set_start_attr: function(){
            this.el.style.display = 'none';
            this.el.style.position = 'absolute';
            this.el.style.backgroundColor = 'rgb(0, 0, 0)';
            this.el.style.padding = '10px';
            this.el.style.color = '#944';
            this.el.style.fontSize = '24px';
          },
          set_left_top: function(){
            this.el.style.left = ((sizes.w - this.el.clientWidth) / 2) + 'px';
            this.el.style.top = ((sizes.h - this.el.clientHeight) / 2) + 'px';            
          },
          set_text: function(text){
            this.el.innerHTML = text; 
          }, 
          set_visibility: function(num){
            if (num === 0){
              this.el.style.display = 'none';
            } else{
              if (this.el.style.display !== 'block'){
                this.el.style.display = 'block';
              }
            }
            
            this.el.style.visibility = '' + num;
          },
          computation_start: function(persents){
            
              if (persents == 0){
                  
                  this.set_text('Для начала нажмите любую клавишу!');
                  this.set_visibility(1 / 100);

              } else if (persents < 30){
                                    
                  this.set_text('3!');
                  this.set_visibility(persents / 100);
                  
              } else if (persents < 60){
                
                  this.set_text('2!');
                  this.set_visibility(persents / 100);
                  
              } else if (persents < 80){
              
                this.set_text('1!');
                this.set_visibility(persents / 100);
                  
              } else if (persents < 99) {
                
                this.set_text('START!');
                this.set_visibility(persents / 100);
                
              } else {
                this.set_visibility(0);
              }
              
               this.set_left_top();              
          },
          show_finish: function(res){
            this.set_left_top();
            this.set_visibility(100);
            this.set_text('Ваш результат ' + res + "<br/> для рестарта игры нажмите любую кнопку!");
          },
        };
        
        var steps_popup = {
          count: 0,
          frames: 0,
          go: false,
        };
        
        // controls the game
        var game = {
          params: road_params,
          sizes: sizes,
          svg: paper,
          array: road_array,
          field: field,
          racer: null,
          steps_r: steps_racer,
          renders_r: renders_racer,
          steps_up: steps_popup,
          up: popup,
          // begin, main, end
          status: '',
          restart: function(){
            this.steps_r.count = 0;
            this.steps_r.cycle = false;
            this.renders_r.status = false;
            this.timer = 0;
            
            console.log('[');
            for (var i in this.racer.flay){
              console.log('{');
              for (var prop in this.racer.flay[i]){
                console.log("'" + prop + "'" + ': ' + this.racer.flay[i][prop]);
              }
              console.log('}, ');
            }
            console.log(']');
            
            this.racer.del();
            
            this.start_game();
          },
          steps_start: function(){
            
            if (this.steps_up.count == 0){
                            
              if (this.steps_up.go){
                this.steps_up.count++;
              }
              
            } else if (this.steps_up.count < this.steps_up.frames){
              
              this.steps_up.count++;
            
            } else {
              
              this.steps_up.count = 0;
              this.status = 'main';              
              
            }
          },
          // start_game!
          start_game: function(){
          
            var xy;
          
            this.racer = new CreateRacer('#FFD', "#D44");
          
            this.status = 'begin';            
                
            this.up.set_start_attr();                    
            this.steps_up.frames = 100;        
            
            xy = this.calcuts_x_y(this.racer.coord.i, this.racer.coord.j);
            
            this.racer.set_path('full', 'M' + xy.x + ',' + xy.y);
                                        
            this.set_racer({
              i: this.racer.coord.i,
              j: this.racer.coord.j, 
            });    
          },
          get_ij_from_xy: function(x, y){
            
            var ij = {
              i: Math.floor(x / this.params.cell),
              j: Math.floor(y / this.params.cell),
            };
                        
            return ij;
          },
          check_finish: (function(){
            
            var timeout;
            
            var ink_timeout = function(the, type){
                            
              if (type){
                the.racer.finish_on++;
              } else {
                the.racer.finish_on--;
              }               
                            
              window.clearTimeout(timeout);
              timeout = undefined;
              
            };
            
            return function(){
                            
              if (this.racer.root > 0 && this.racer.root < 4){
                if (this.array[this.racer.coord.i][this.racer.coord.j] == 2){
                  if (this.racer.finish_on > 0){
                    if (timeout === undefined){
                      timeout = window.setTimeout(ink_timeout, 1000, this, false);
                    }
                  } else {
                    this.status = 'end';
                    this.racer.speed = 0;
                    this.up.show_finish(this.timer); 
                  }
                }    
              } else {
                if (this.array[this.racer.coord.i][this.racer.coord.j] == 2){
                  if (timeout === undefined){
                    timeout = window.setTimeout(ink_timeout, 1000, this, true);
                  }
                }
              }
            };
            
          }()),  
          // set racer in road without animate
          set_racer: function(coord){

            var xy = this.calcuts_x_y(coord.i, coord.j);
            var params_view = this.get_viewBox(xy.x, xy.y, this.steps_r.frames);
            
            this.racer.coord.i = coord.i;
            this.racer.coord.j = coord.j;
            this.racer.coord.x = xy.x;
            this.racer.coord.y = xy.y;
                  
            this.racer.set_racer(xy.x, xy.y, this.racer.current_speed_root.r);                                                
            this.racer.set_path('full', 'L' + xy.x + ',' + xy.y);
            
            //console.log(this.racer.path.str);
            
            paper.setViewBox(params_view.x, params_view.y, params_view.w, params_view.h);
          },
          // gets params for viewBox 
          get_viewBox: (function(){
          
            var w, h, x, y;
            var older_speed = 0;
            var type_calcuts = 'qul';
            var scale;
            var add_scale = 0.7;

            return function(x_racer,  y_racer, count){        
                            
              if (count === 1){ 
                if (this.racer.speed > older_speed){
                  type_calcuts = 'up';
                } else if (this.racer.speed < older_speed) {                  
                  type_calcuts = 'down';
                } else {
                  type_calcuts = 'qul';
                }
                
                older_speed = this.racer.speed;
              }
              
              //console.log('calcuts_scale', type_calcuts, this.speed, count);
              
              switch(type_calcuts){
                case 'up':
                  scale = add_scale + (older_speed - 1 + (1 / this.steps_r.frames * count)) * 0.1;
                break;
                case 'down':
                  scale = add_scale + (older_speed + 1 - (1 / this.steps_r.frames * count)) * 0.1;
                break;
                case 'qul':
                  scale = add_scale + older_speed* 0.1;
                break
              }
              
              w = sizes.w * scale;
              h = sizes.h * scale;
              x = x_racer - w / 2;              
              y = y_racer - h / 2;
                            
              return {
                x: x,
                y: y,
                w: w,
                h: h,
              };
            }
          }()),  
          // calcuts_x_y from i, j
          calcuts_x_y: function(i, j){
            return {
                x: i * road_params.cell + road_params.cell / 2,
                y: j * road_params.cell + road_params.cell / 2,
              };
          },
          // goes move for racer
          racer_go: function(){
          
            var s;
            var i = this.racer.coord.i;
            var j = this.racer.coord.j;
            var the = this;
            
            switch (this.racer.root){
              case 0:
                for (s = 1; s <= this.racer.speed; s++ ){
                                                      
                  if (this.array[i][j - s] && this.array[i][j - s] === 1){
                                        
                    s--;
                    boomb(i, j - s);                    
                    break;
                  } 
                                                      
                  if (s == this.racer.speed){
                    set_goal(i, j - s);                    
                  }

                }
              break;
              case 1:
                for (s = 1; s <= this.racer.speed; s++ ){
                  if (this.array[i + s] && this.array[i + s][j - s] && this.array[i + s][j - s] === 1){
                    
                    s--;
                    boomb(i + s, j - s);
                    break;
                  } 
                  
                  if (s == this.racer.speed){
                    set_goal(i + s, j - s);
                  }
                }
              break;
              case 2: 
                for (s = 1; s <= this.racer.speed; s++ ){
                  if (this.array[i + s] && this.array[i + s][j] && this.array[i + s][j] === 1){
                    s--;                                        
                    boomb(i + s, j);
                    break;
                  } 
                  
                  if (s == this.racer.speed){
                    set_goal(i + s, j);
                  }
                }
              break;
              case 3: 
                for (s = 1; s <= this.racer.speed; s++ ){
                  if (this.array[i + s] && this.array[i + s][j + s] && this.array[i + s][j + s] === 1){
                    s--;
                    boomb(i + s, j + s);
                    break;
                  } 
                  
                  if (s == this.racer.speed){
                    set_goal(i + s, j + s);
                  }
                }
              break;
              case 4: 
                for (s = 1; s <= this.racer.speed; s++ ){
                  if (this.array[i][j + s] && this.array[i][j + s] === 1){
                    s--;
                    boomb(i, j + s);
                    break;
                  } 
                  
                  if (s == this.racer.speed){
                    set_goal(i, j + s);
                  }
                }              
              break;
              case 5: 
                for (s = 1; s <= this.racer.speed; s++ ){
                  if (this.array[i - s] && this.array[i - s][j + s] && this.array[i - s][j + s] === 1){
                    s--;
                    boomb(i - s, j + s);
                    break;
                  } 
                  
                  if (s == this.racer.speed){
                    set_goal(i - s, j + s);
                  }
                }
              break;
              case 6:
                for (s = 1; s <= this.racer.speed; s++ ){
                  if (this.array[i - s] && this.array[i - s][j] && this.array[i - s][j] === 1){
                    s--;
                    boomb(i - s, j);
                    break;
                  } 
                  
                  if (s == this.racer.speed){
                    set_goal(i - s, j);
                  }
                }
              break;
              case 7: 
                for (s = 1; s <= this.racer.speed; s++ ){
                  if (this.array[i - s] && this.array[i - s][j - s] && this.array[i - s][j - s] === 1){
                    s--;
                    boomb(i - s, j - s);
                    break;
                  } 
                  
                  if (s == this.racer.speed){
                    set_goal(i - s, j - s);
                  }
                }
              break;
            }
            
            this.racer.current_speed_root.s = this.racer.speed;
            this.racer.current_speed_root.r = this.racer.root;
            
            // move racer in i, j
            function set_goal(goal_i, goal_j){
              
              var xy = the.calcuts_x_y(goal_i, goal_j);
              
              steps_racer.cycle = true;
              steps_racer.goal.i = goal_i;
              steps_racer.goal.j = goal_j;
              steps_racer.goal.x = xy.x;
              steps_racer.goal.y = xy.y;
            }
            // breack racer in i, j
            function boomb(racer_i, racer_j){
                        
              the.steps_r.count = 0;
              the.steps_r.cycle = false;

              the.set_racer({i:racer_i, j:racer_j});
              the.racer.speed = 0;

              the.racer.root = (function(road, i, j){
                if (road[i][j - 1] !== 0){
                  return 4;
                } else if (road[i + 1] && road[i + 1][j] !== 0){
                  return 6;
                } else if (road[i][j + 1] !== 0){
                  return 0;
                } else if (road[i - 1] && road[i - 1][j] !== 0){
                  return 2;
                } else {
                  return 2;
                }
              }(the.array, racer_i, racer_j));
            
            }
            
          },
          // calcuts x, y for next frame rendering racer  
          steps_for_racer: (function(){
            
            var xy;
            var ij;

            return function(){
              // calcuts the go
              
              this.timer++;
              
              if (this.steps_r.count < this.steps_r.frames){
                if (this.steps_r.count == 0){
                  this.steps_r.path = 'M' + this.racer.coord.x + ',' + this.racer.coord.y + 
                                          'L' + this.steps_r.goal.x + ',' + this.steps_r.goal.y;
                  this.steps_r.bit = Raphael.getTotalLength(this.steps_r.path) / this.steps_r.frames;
                  
                  this.steps_r.begin_path = 'M' + this.racer.coord.x + ',' + this.racer.coord.y; 
                                                      
                  this.renders_r.status = true;
                  this.steps_r.count++;
                }

                xy = Raphael.getPointAtLength(this.steps_r.path, 
                                      this.steps_r.count * this.steps_r.bit);
                
                this.renders_r.viewBox = this.get_viewBox(xy.x, xy.y, this.steps_r.count);
                                
                this.renders_r.racer = xy;
                
                this.racer.coord.x = xy.x;
                this.racer.coord.y = xy.y;
                
                ij = this.get_ij_from_xy(xy.x, xy.y);
                
                this.racer.coord.i = ij.i;
                this.racer.coord.j = ij.j;

                if (this.steps_r.count == this.steps_r.frames - 1){
                  this.renders_r.path = '';
                } else {
                  this.renders_r.path = this.steps_r.begin_path + 'L' + xy.x + ',' + xy.y;
                }
                            
                this.steps_r.count++;
              } else {
              // end move for racer
                this.steps_r.count = 0;
                this.renders_r.status = false;
                
                this.racer.coord.i = this.steps_r.goal.i;
                this.racer.coord.j = this.steps_r.goal.j;
                this.racer.coord.x = this.steps_r.goal.x;
                this.racer.coord.y = this.steps_r.goal.y;
                              
                this.set_racer({i: this.steps_r.goal.i, j: this.steps_r.goal.j});
              }
            };

          }()),
          //draw freme for move racer
          renders_for_racer: function(){
                        
            this.racer.set_racer(this.renders_r.racer.x, this.renders_r.racer.y, this.racer.current_speed_root.r);
                          
            this.svg.setViewBox(this.renders_r.viewBox.x, this.renders_r.viewBox.y,
                                   this.renders_r.viewBox.w, this.renders_r.viewBox.h);
                                   
            this.racer.set_path('anim', this.renders_r.path);                       
          },
          key_down_for_racer: function(data){
                      
            switch(data.key){
              case 'up':
                if (this.racer.speed < 10 && this.racer.current_speed_root.s >= this.racer.speed){
                  this.racer.speed++;
                }
              break;
              case 'down':
                if (this.racer.speed > 0 && this.racer.current_speed_root.s <= this.racer.speed){
                  this.racer.speed--;
                }
              break;
              case 'right':
                if (this.racer.current_speed_root.r == 7 && this.racer.root == 7){
                  this.racer.root = 0;
                } else if (this.racer.current_speed_root.r < 7 && this.racer.current_speed_root.r >= this.racer.root){
                  this.racer.root++;
                }
              break;
              case 'left':
                if (this.racer.current_speed_root.r == 0 && this.racer.root == 0){
                  this.racer.root = 7;
                } else if (this.racer.current_speed_root.r > 0 && this.racer.current_speed_root.r <= this.racer.root){
                  this.racer.root--;
                }
              break;
            }
          },
        };
        
        game.start_game();
        
        this._gm_ = game;
        
        this.step = function(){

          switch(this._gm_.status){
            case 'begin':
              this._gm_.steps_start();
            break;
            case 'main':
            
              if (this._gm_.steps_r.count == 0){
                if (this._gm_.speed > 0){
                  this._gm_.racer.flay.push({s: this._gm_.speed, r: this._gm_.root});
                } else {
                  if (this._gm_.racer.flay[this._gm_.racer.flay.length - 1].s === 0){
                    this._gm_.racer.flay[this._gm_.racer.flay.length - 1].wait++;
                  } else {
                    this._gm_.racer.flay.push({s: 0, wait: 0});
                  }
                }
              }
            
              this._gm_.check_finish();
              
              if (this._gm_.steps_r.cycle){
                this._gm_.steps_for_racer();
              }
              // start calcuts params for render if it is needs
              if (this._gm_.steps_r.count == 0){
                if(this._gm_.racer.speed > 0){
                  this._gm_.racer_go();
                } else {
                  if (this._gm_.steps_r.cycle){
                      this._gm_.steps_r.cycle = false;
                    }
                }
              }            
            break;
            case 'end':
              //console.log('game_end!', this._gm_.timer);
            break;
          }
        };
        
        this.render = function(){
          switch(this._gm_.status){
            case 'begin':
              this._gm_.up.computation_start(100 * this._gm_.steps_up.count / this._gm_.steps_up.frames);
            break;
            case 'main':
              if (this._gm_.renders_r.status){
                this._gm_.renders_for_racer();
              }
            break;
            case 'end':
            break;
          }          
        };
        
        this.keydown = function(data){
          
          switch (this._gm_.status){
            case 'begin':
              this._gm_.steps_up.go = true;
            break;
            case 'main':
              game.key_down_for_racer(data)
            break;
            case 'end':
              this._gm_.restart();
            break;
          }
        };
      },
    };

    // main Application of the game
     var app = new PLAYGROUND.Application({

      //there is loading resorce
      create: function(){

        this._sizes_ = {
          w: window.innerWidth,
          h: window.innerHeight,
        };
        
         this._svg_ = Raphael(0, 0, this._sizes_.w, this._sizes_.h);
      },
      // call after loading
      ready: function(){
        
        this.setState(ENGINE.main);
      },
      
      resize: function(){
        
        this._sizes_.w = window.innerWidth;
        this._sizes_.h = window.innerHeight;
        
        this._svg_.canvas.style.width = this._svg_.canvas.width = this._svg_.width = this._sizes_.w;
        this._svg_.canvas.style.height = this._svg_.canvas.height = this._svg_.height = this._sizes_.h;
        
      },   
    });

    </script>
  </body>
</html>
